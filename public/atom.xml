<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Yonney's Blog]]></title>
  <subtitle><![CDATA[越努力才会越幸运]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://mikiyonney.github.io//"/>
  <updated>2014-06-12T13:09:11.411Z</updated>
  <id>http://mikiyonney.github.io//</id>
  
  <author>
    <name><![CDATA[MiKi Yonney]]></name>
    <email><![CDATA[mikiyonney@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[HuiYin Lin]]></title>
    <link href="http://mikiyonney.github.io/2014/06/12/lin-hui-yin/"/>
    <id>http://mikiyonney.github.io/2014/06/12/lin-hui-yin/</id>
    <published>2014-06-12T11:25:06.000Z</published>
    <updated>2014-06-12T13:08:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="林徽因「一身诗意千寻瀑，万古人间四月天」">林徽因「一身诗意千寻瀑，万古人间四月天」</h2>
<p>深深的记得本科的一闺蜜特别喜欢林徽因，也曾经在想，作为程序媛的她为何如计算机这一行，她其实本身在我眼中也是极具有民国女子的那种美丽与优雅的。这段时间也许是今年最闲的时段，可以毫无牵挂的去看自己任何想看的书，无比喜欢这种日子。知道20几天后立马会是职场上无尽的奋斗，现在要好好珍惜这段日子，虽然一个人天天泡图书馆没人说话是无聊的，但是其间是无比的充实，看看书，敲敲代码。</p>
<p>了解林徽因，最深刻的就是「万古人间四月天」以及「我懂你就像懂我自己一样深刻」。林徽因，她几乎是她那个时代颜色的一种标志，令我欣赏的是不仅仅其出众的才，倾城的貌，更让我佩服的是，她的独立、空灵与优雅——耐得住学术的寂寞和冷清，受得住生活的艰辛和贫困，为理想不停的奋斗，不愧为胡适口中的“一代才女”。<a id="more"></a></p>
<p>参与国徽的设计、改造景泰蓝、设计天安门人民英雄纪念碑是这个美丽的女子这生实现自己理想，并为祖国做出莫大贡献的重要的三件事。读完传记才知道，原来东北大学的校徽也是出自她之手，她在建筑学上的造诣是极高的。以至于在和梁思成认识后，影响梁也对建筑学产生了莫大的兴趣。</p>
<p>林徽因在文学方面的成就除了其家庭环境的影响，也与对她百般迷恋的徐志摩分不开。胡适曾说徐志摩的人生观只有三点：爱、自由、美。徐志摩对自由的向往以至于后来和包办婚姻而来的妻子张幼仪的离婚，风流才子，浪漫多情。他把林徽因刻在了自己的心壁，她永远是他心中的那段柔波，在快乐寂寥和忧伤的时候泛起细碎的光。可是，林徽因是理智的，她知道自己如果与徐在一起，张幼仪就可能想自己母亲那样活着，而且还要承受世人异样的眼光，最终还是她让徐志摩魂断康桥。</p>
<p>徐志摩对林的爱恋是都存在的，以至于即使她结婚后，时常和她畅聊文学诗歌，能与她有心灵共鸣的还是徐志摩。再最难过失意的时候林徽因想到的也是徐志摩。理智的林徽因其实是爱她的，担她只能默默的爱着他，作他生命力的一缕清风。林徽因曾对其子女说：“徐当时爱的并不是真正的我，而是他用诗人的浪漫情绪想象出来的林徽因，可我其实并不是他心中所想的那个人”。</p>
<p>每个人生命中也许都会有那个徐志摩的存在。</p>
<p>人生得一段完美的感情，此生足矣。这样的完美需要两个人心心相映，相容相知。徐智谋不过是林徽因心底角落里的一朵梅痕，梁思成才是那个她觉得可以携手一生的人。梁思成和她有着相濡以沫的感情，他们共同留学，一起攻读建筑学，到处参观研究古建筑，她们是晴空下相连的双湖，连系他们的河道，永世流淌着延绵着爱意。然而在文学上的孤独，梁思成给不了林徽因。梁思成在林徽因去世之后，又娶了了十分崇拜林徽因的林洙，这是让我很难过失望的，多少为林徽因觉得不值，也许换做她嫁给徐志摩，徐志摩会不会恋她一生，不会再娶。因为徐志摩爱的那么浓烈，用尽生命去爱林徽因。</p>
<p>“一身诗意千寻瀑，万古人间四月天”。这是金岳霖写给林徽因的挽联。金岳霖，这个为了林徽因终生不娶的哲学爱好者。他一直与梁思成他们夫妇为邻居，他用一生的痴爱和一辈子的坚守始终站在林徽因身边，默默关注着她的尘世沧桑，苦苦相随她生命的悲和喜，这种发乎情，止乎礼，这种远超乎简单男女之情的倾慕和忠贞，让多少人叹服。人，最美的时刻，就是有人在至老的时候还会想起你，那样深刻，深刻到他一生都从未忘怀。</p>
<p>林徽因，她不做别人眼里的传奇，只想踏踏实实地过一生。如果他们能早些相遇，如果她没有知道在他的生命力，如果人生只若初见，或许他们可以在时光里慢慢皓首。但是人生没有如果，之后后果和结果。因缘际会，光影流转，很难说清到底谁是谁应了谁的劫难。</p>
<p>“我懂你就像懂我自己一样深刻”。那些心照不宣的爱情，你若盛开，清风自来。</p>
<p>如果我的心是一朵莲花，我也要它骄傲的捧出辉煌，做一个心若莲花的女子，做最美的自己。心若莲花亦倾城，最美不过林徽因。</p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="林徽因「一身诗意千寻瀑，万古人间四月天」">林徽因「一身诗意千寻瀑，万古人间四月天」</h2>
<p>深深的记得本科的一闺蜜特别喜欢林徽因，也曾经在想，作为程序媛的她为何如计算机这一行，她其实本身在我眼中也是极具有民国女子的那种美丽与优雅的。这段时间也许是今年最闲的时段，可以毫无牵挂的去看自己任何想看的书，无比喜欢这种日子。知道20几天后立马会是职场上无尽的奋斗，现在要好好珍惜这段日子，虽然一个人天天泡图书馆没人说话是无聊的，但是其间是无比的充实，看看书，敲敲代码。</p>
<p>了解林徽因，最深刻的就是「万古人间四月天」以及「我懂你就像懂我自己一样深刻」。林徽因，她几乎是她那个时代颜色的一种标志，令我欣赏的是不仅仅其出众的才，倾城的貌，更让我佩服的是，她的独立、空灵与优雅——耐得住学术的寂寞和冷清，受得住生活的艰辛和贫困，为理想不停的奋斗，不愧为胡适口中的“一代才女”。]]></summary>
    
      <category term="读书笔记" scheme="http://mikiyonney.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="札记" scheme="http://mikiyonney.github.io/categories/%E6%9C%AD%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Projects Summary]]></title>
    <link href="http://mikiyonney.github.io/2014/05/21/projects-summary-2013.9~2014.5/"/>
    <id>http://mikiyonney.github.io/2014/05/21/projects-summary-2013.9~2014.5/</id>
    <published>2014-05-21T14:29:59.000Z</published>
    <updated>2014-06-08T13:01:27.000Z</updated>
    <content type="html"><![CDATA[<h2 id="项目总结「善以不变应万变者得天下」">项目总结「善以不变应万变者得天下」</h2>
<p>从研究生入学的第一天（2013-9-2）起加入这个项目，到目前为止（2014-5-27）大致半年的时间，如人饮水，冷暖自知，期间的各种酸甜苦辣至少让研一的生活不至于太单调无趣，现终于已接近尾声，也算给研一的生活划上圆满的句号了。还剩一个月的时间要去实习了，且行且珍惜。<br><a id="more"></a></p>
<p>项目我们Team主要负责维也纳酒店工程报修流程模块，也就是类似于工作流模型结合十分务必复杂的业务逻辑的实现。期间变过N次需求，提出过4种技术方案，曾为研究出实现方案后兴奋过，也曾中途没法做下去想过放弃项目，但还好后来还是挺过来了没让项目烂尾。大概自己做完项目后的心得如下：</p>
<p><strong>一.好的设计是成功的一半。</strong></p>
<p>针对工程报修模块，从一开始到项目结束大概提出了四套方案，前三种方案都是为了需求的设计，终于当需求在无法掌控的范围的时候，急需一个为了设计的设计才能应对变化。</p>
<p><strong>方案一</strong>：用JBPM5.4，失败原因主要是：5.4版本的学习成本大，加上系统业务太复杂，项目需要成果交差，于是在经过一个月的研究后终于还是选择放弃了。不过，想想那一个月，整个team在研究出一点成果是的哪种喜悦之情，至今想起来还是一件很美好的事。</p>
<p><strong>方案二</strong>：用状态机驱动，大概就是枚举出系统所有的状态，控制每种角色可见的状态，每个状态对应什么后续操作即可。这个方案一直撑到了今年的年初，后来需求“终于”又发生了变化，系统的状态已经有一百多个了，整个系统完全变得不可维护了。此外，有些节点的超时等在代码中写死了，只要需求一边就傻了，切记你永远不知道客户在想什么，所以还是写点灵活的东西来成全别人顺便轻松自己吧。</p>
<p><strong>方案三</strong>：状态机驱动，只是在原来的表上增加了状态的转移目标，也就是角色可见什么状态，通过什么操作到达什么状态，这也是一个枚举的过程，这个方案在实行两天后就被方案四代替了，现在想想枚举真是一件很恐怖的事情。</p>
<p><strong>方案四</strong>：也就是最终解决客户各种需求变化的方案。大致用数据库模拟了一个工作流引擎。系统可配置化，关键数据库设计为：流程类型表（workflow）+节点表(Node)+节点操作关联（nodeOperationRel）+节点角色关联(nodeRoleRel)+操作表(Operation)+任务表（tasks）。</p>
<p><strong>二.没有技术解决不了的问题，只有想不想做的问题。</strong></p>
<p>技术的路上总会有很多surprise，因为有些东西在你看来可能没法实现的，但是它总是能被人解决。且当它被解决时，你总会有想研究这个问题的本质所在，这就是一个驱动式学习的过程。与其总说研究生是个坑，还不如说它给了我很多自由时间，让我提升自己自学的能力，让我真真正正在一群专业的搞技术的人的熏陶下提高自己，感恩……</p>
<p><strong>三.你不是一个人在战斗，永远要相信团队的力量。</strong></p>
<p>团队沟通和合作很重要，我们Team有一个前端，一个算法高手，一个java后台，三个人常在群里“吐槽”，虽然有时候觉得项目很“坑”，但是感觉整个团队还是很欢乐，至少我是这样觉得的。团队合作的过程中，你总会感觉别人有多牛逼多牛逼，然后你就必须得学，以至于不会掉太远。还有有时候如果觉得一个人坚持不下去的时候，可以找朋友们谈个心^—^,因为每个人的想法都会不同，就算他们不能给你帮助，可是总会很多正能。有些事情，吐槽一下就够了，快乐的生活还得继续，唯有接受挑战，才能让自己真正的有所提升。</p>
<p>我已经在IT这条路上渐行渐远了，既然已经渐远了，已经准备一直走下去了。无论做什么，只要能让自己有收获，有成就感，无悔于青春，我都很乐意。请叫我程序媛。</p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="项目总结「善以不变应万变者得天下」">项目总结「善以不变应万变者得天下」</h2>
<p>从研究生入学的第一天（2013-9-2）起加入这个项目，到目前为止（2014-5-27）大致半年的时间，如人饮水，冷暖自知，期间的各种酸甜苦辣至少让研一的生活不至于太单调无趣，现终于已接近尾声，也算给研一的生活划上圆满的句号了。还剩一个月的时间要去实习了，且行且珍惜。<br>]]></summary>
    
      <category term="Java" scheme="http://mikiyonney.github.io/tags/Java/"/>
    
      <category term="Java" scheme="http://mikiyonney.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Migration Of My Old Blogs]]></title>
    <link href="http://mikiyonney.github.io/2014/04/15/migration-of-my-old-blog/"/>
    <id>http://mikiyonney.github.io/2014/04/15/migration-of-my-old-blog/</id>
    <published>2014-04-15T06:19:05.000Z</published>
    <updated>2014-04-15T06:36:27.000Z</updated>
    <content type="html"><![CDATA[<h2 id="旧博客搬迁至此">旧博客搬迁至此</h2>
<p>在这里那里写技术总结，发现到最后感觉是零星点点，记账号也是一件特别麻烦的事，找回以前的博客地址，mark如下：</p>
<p>1.<a href="http://write.blog.csdn.net/postlist" target="_blank">Blog IN CSDN</a></p>
<p>2.<a href="http://my.oschina.net/Yonney" target="_blank">Blog IN Oschina</a></p>
]]></content>
    
    
      <category term="Blog" scheme="http://mikiyonney.github.io/tags/Blog/"/>
    
      <category term="Blog" scheme="http://mikiyonney.github.io/categories/Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sorting Algorithm In Java]]></title>
    <link href="http://mikiyonney.github.io/2014/04/12/sorting-algorithm-in-java/"/>
    <id>http://mikiyonney.github.io/2014/04/12/sorting-algorithm-in-java/</id>
    <published>2014-04-12T07:19:33.000Z</published>
    <updated>2014-04-12T08:23:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="常用排序算法在java中的实现">常用排序算法在java中的实现</h2>
<p>最近一段时间的复习深刻的觉得算法和数据结构的重要性之所在，总结下常用的排序算法在java中的实现方式。如图所示：<br><a id="more"></a></p>
<img src="http://i.imgur.com/SotgAgr.png" class="introduction" title="[title [alt 操作系统绪论]]">


<p>具体的java实现代码请参考：<a href="https://github.com/MiKiYonney/SortingAlgorithmInJava" target="_blank">SortingAlgorithmInJava</a></p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="常用排序算法在java中的实现">常用排序算法在java中的实现</h2>
<p>最近一段时间的复习深刻的觉得算法和数据结构的重要性之所在，总结下常用的排序算法在java中的实现方式。如图所示：<br>]]></summary>
    
      <category term="Algorithm" scheme="http://mikiyonney.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://mikiyonney.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Summary of develop Errors]]></title>
    <link href="http://mikiyonney.github.io/2014/04/01/summary-of-develop-errors-/"/>
    <id>http://mikiyonney.github.io/2014/04/01/summary-of-develop-errors-/</id>
    <published>2014-04-01T09:58:16.000Z</published>
    <updated>2014-04-01T10:12:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="在开发过程中常见的错误总结（定期更新）">在开发过程中常见的错误总结（定期更新）</h2>
<h4 id="1-hibernate配置文件中大小写问题">1.hibernate配置文件中大小写问题</h4>
<p>遇到过两次，在windows下项目能够正常启动, 在linux下项目不能够正常启动, 报 xx.hbm.xml不存在.<br>Linux下文件区分大小写，window下文件不区分大小写，譬如：</p>
<pre><code>&lt;<span class="type">class</span> <span class="property">name</span>=<span class="string">"com.mckj.entity.QuickasProjectrepairreq"</span> table=<span class="string">"quickas_projectrepairreq"</span> catalog=<span class="string">"wyn"</span>&gt;
</code></pre><p>如table的名称在mysql数据库中默认会为小写，windows下反向工程可能会按照驼峰生成为quickas_projectRepairReq,这样在windows下正常，在linux下就会报错了！改成小写即可~</p>
]]></content>
    
    
      <category term="Java" scheme="http://mikiyonney.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Singleton Pattern In JAVA]]></title>
    <link href="http://mikiyonney.github.io/2014/03/16/singleton-pattern-in-java/"/>
    <id>http://mikiyonney.github.io/2014/03/16/singleton-pattern-in-java/</id>
    <published>2014-03-16T07:06:30.000Z</published>
    <updated>2014-03-16T07:28:27.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Java单例实现">Java单例实现</h2>
<p><strong>一、为什么要用单例模式</strong></p>
<p>当一个类需要用来管理共享资源的时候，我们就只需要一个对象，比方说：线程池、缓存、日志对象等。如果说制造出了多个实例，就会导致许多问题的产生，例如：程序异常，资源使用过量，结果不一致等。</p>
<p><strong>二、Java实现单例思想：</strong></p>
<ol>
<li>私有构造函数 → 其他类不能实例化一个新的对象。</li>
<li>私有化引用 → 不能进行外部修改。</li>
<li>公有静态方法是唯一可以获得对象的方式。<a id="more"></a>

</li>
</ol>
<p><strong>三、实现方法</strong></p>
<p>1.经典实现方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="keyword">package</span> com.singleton;
<span class="javadoc">/**
 * 懒汉写法  缺点：没有达到lazy loading的效果
 * 金典单例实现只适用于单线程的情况，当有多个线程并发时，
 * 它们都要执行这段代码，都执行到第6行，这时 sl都为空，于是乎就会实例出多个对象了，这就违背了单例模式的思想了。
 *  *<span class="javadoctag"> @author</span> yonney
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> {</span>
     <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton singleton;
     <span class="keyword">private</span> <span class="title">LazySingleton</span>(){
           
     }
     <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span>(){
            <span class="keyword">if</span>( singleton== <span class="keyword">null</span>){
                 singleton = <span class="keyword">new</span> LazySingleton();
           }
            <span class="keyword">return</span> singleton;
     }
}
</pre></td></tr></table></figure>

<p>2.getInstance()方法上加上synchronized关键字</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Singleton {
    <span class="keyword">private</span> <span class="keyword">static</span> Singleton sl;
    <span class="keyword">private</span> <span class="title">Singleton</span>() {
    }
    <span class="keyword">public</span> <span class="keyword">static</span> synchronized Singleton <span class="title">getInstance</span>() {
        <span class="keyword">if</span>(sl == <span class="keyword">null</span>) {
            sl = <span class="keyword">new</span> Singleton();
        }
        <span class="keyword">return</span> sl;
    }
    <span class="comment">//其他的方法</span>
}
</pre></td></tr></table></figure>

<p><strong>注意</strong>：但是我们可以想象得到，真正需要同步的是在第一次调用时，之后就不再需要同步这个方法了。之后的每次调用，同步都会是一种累赘。程序执行的效率就会大大降低。</p>
<p>3.恶汉写法(JVM虚拟机在加载这个类时就会立马创建此唯一的单例。)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> HungrySingleton {
     <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton singleton = <span class="keyword">new</span> HungrySingleton();
     <span class="keyword">private</span> <span class="title">HungrySingleton</span>(){
           
     }
     <span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span>(){
            <span class="keyword">return</span> singleton;
     }
}
</pre></td></tr></table></figure>

<p>4.双重校验锁，在当前的内存模型中无效</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> LockSingleton {
     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LockSingleton singleton;
     <span class="keyword">private</span> <span class="title">LockSingleton</span>(){
           
     }
     <span class="keyword">public</span> <span class="keyword">static</span> LockSingleton <span class="title">getInstance</span>(){
            <span class="keyword">if</span>( singleton == <span class="keyword">null</span>){
                 synchronized (LockSingleton. class) {
                      <span class="keyword">if</span>( singleton == <span class="keyword">null</span>){
                            singleton = <span class="keyword">new</span> LockSingleton();
                     }
                }
           }
            <span class="keyword">return</span> singleton;
     }
}
</pre></td></tr></table></figure>

<p>5.内部静态方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="javadoc">/**
 * 内部静态方法  优点：加载时不会初始化静态变量INSTANCE，因为没有主动使用，达到Lazy loading
 *<span class="javadoctag"> @author</span> yonney
 *
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalSingleton</span> {</span>
     <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span>{</span>
            <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> InternalSingleton INSTANCE = <span class="keyword">new</span> InternalSingleton();
     }
     <span class="keyword">private</span> <span class="title">InternalSingleton</span>(){
           
     }
     <span class="keyword">public</span> <span class="keyword">static</span> InternalSingleton <span class="title">getInstance</span>(){
            <span class="keyword">return</span> SingletonHolder. INSTANCE;
     }
}
</pre></td></tr></table></figure>


<p>6.枚举实现</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="javadoc">/**
 * 枚举，《Effective Java》作者推荐使用的方法，优点：不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象
 *<span class="javadoctag"> @author</span> yonney
 */</span>
<span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton {
     INSTANCE;
     <span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span>(){
            <span class="keyword">return</span> INSTANCE ;
     }
     <span class="keyword">public</span> Object o;
     <span class="keyword">public</span> Object <span class="title">testObject</span>(){
            <span class="keyword">if</span>( o== <span class="keyword">null</span>){
                 <span class="keyword">return</span> <span class="keyword">new</span> Object();
           }
            <span class="keyword">return</span> o;
     }
     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String args[]){
           <span class="keyword">if</span>(EnumSingleton. getInstance().testObject()==EnumSingleton. getInstance().testObject()){
           }
     }
}
</pre></td></tr></table></figure>

<hr>
]]></content>
    <summary type="html"><![CDATA[<h2 id="Java单例实现">Java单例实现</h2>
<p><strong>一、为什么要用单例模式</strong></p>
<p>当一个类需要用来管理共享资源的时候，我们就只需要一个对象，比方说：线程池、缓存、日志对象等。如果说制造出了多个实例，就会导致许多问题的产生，例如：程序异常，资源使用过量，结果不一致等。</p>
<p><strong>二、Java实现单例思想：</strong></p>
<ol>
<li>私有构造函数 → 其他类不能实例化一个新的对象。</li>
<li>私有化引用 → 不能进行外部修改。</li>
<li>公有静态方法是唯一可以获得对象的方式。]]></summary>
    
      <category term="Design Pattern" scheme="http://mikiyonney.github.io/tags/Design%20Pattern/"/>
    
      <category term="Java" scheme="http://mikiyonney.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Cloud Emulator]]></title>
    <link href="http://mikiyonney.github.io/2014/01/08/android-cloud-emulator/"/>
    <id>http://mikiyonney.github.io/2014/01/08/android-cloud-emulator/</id>
    <published>2014-01-08T06:55:34.000Z</published>
    <updated>2014-03-16T06:24:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Android云端模拟器">Android云端模拟器</h2>
<p>最近闲来无事弄下Android，想做个APP练练手，以前一直有这想法，只是没有实现O^O,电脑的配置实在在捉急了，昨天晚上搭好环境后第一次启动模拟器大概花了20分钟，我都不记得漫长的等待过程中的那种感受了，今天google了下云端的模拟器，觉得很赞，因为健忘所以写篇blog记录下。</p>
<p>大致研究了两个Cloud Emulator： <a href="https://www.manymo.com/" target="_blank">manymo</a>和<a href="http://www.genymotion.com/" target="_blank">genymotion</a></p>
<a id="more"></a>

<p>1.先note genymotion,因为这个是成功了的。<br>Step1:<a href="http://www.genymotion.com/" target="_blank">注册genymotion账号</a></p>
<p>Step2:<a href="https://cloud.genymotion.com/page/launchpad/download/" target="_blank">下载Genymotion安装包</a></p>
<p>Step3:安装，按指示傻瓜式安装就好了。</p>
<p>成功之后，进入Genymotion，add,用Genymotion登录，选择一个device点击next就好。</p>
<p>Step4:在eclipse中安装genymotion插件。</p>
<p>(1).在线安装：启动Eclipse，Help-&gt;Install New Software…-&gt;Add,输入：Name: Genymobile   Location: <a href="http://plugins.genymotion.com/eclipse" target="_blank">http://plugins.genymotion.com/eclipse</a></p>
<p>(2).手动安装：<a href="https://cloud.genymotion.com/page/launchpad/download/" target="_blank">下载Eclipse插件</a>,将下载好的插件jar文件放到你eclipse安装目录下的plugins目录下，然后启动eclipse.</p>
<p>在eclipse中ctrl+6启动该插件，首次使用时要指定Genymotion安装目录和SDK目录</p>
<p>2.manymo：速度还不错，在浏览器中运行还比较流畅，但是不知道为什么电脑一直配置没成功，于是才转向了genymotion。下面只是是配置笔记~有成功的欢迎分享。</p>
<p>在Eclipse中配置ManyMo：</p>
<p>(1).<a href="https://www.manymo.com/ManymoSetup.exe" target="_blank">installation manymo program</a></p>
<p>(2).Authentication Token：Win+R→cmd→输入：manymo token</p>
<p>(3).Android SDK Platform Tools配置，下载<a href="http://developer.android.com/sdk/index.html" target="_blank">Android SDK</a>后配置path,path:E:\android\adt-bundle-windows-x86-20131030\sdk\platform-tools</p>
<p>(4)模拟器本地化：</p>
<p>访问<a href="https://www.manymo.com/" target="_blank">manymo</a>，点击develop，copy:manymo tunnel w3d.manymo.com:5556:jCYdPc3 ,在cmd中执行（不知道为什么我在这儿就报错了，一直没解决，然后我就转向了genymotion了）</p>
<p>关闭tunnel：manymo shutdown SERIALNUMBER </p>
<p>查看正在运行的device:adb devices</p>
<p>(5).在eclipse中，在创建的android项目上，点run configuration→选择Target→ Deployment Target Selection Mode：Always prompt to pick device→close</p>
<p>Last:开始develop吧，虽然很多人说java不好-_-!</p>
<p>参考：</p>
<p><a href="http://blog.csdn.net/henren555/article/details/9700027" target="_blank">Android模拟器Genymotion安装向导</a></p>
<p><a href="http://my.oschina.net/ryanhoo/blog/141824" target="_blank">快到极致的Android模拟器——Genymotion</a></p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="Android云端模拟器">Android云端模拟器</h2>
<p>最近闲来无事弄下Android，想做个APP练练手，以前一直有这想法，只是没有实现O^O,电脑的配置实在在捉急了，昨天晚上搭好环境后第一次启动模拟器大概花了20分钟，我都不记得漫长的等待过程中的那种感受了，今天google了下云端的模拟器，觉得很赞，因为健忘所以写篇blog记录下。</p>
<p>大致研究了两个Cloud Emulator： <a href="https://www.manymo.com/" target="_blank">manymo</a>和<a href="http://www.genymotion.com/" target="_blank">genymotion</a></p>
]]></summary>
    
      <category term="android Emulator" scheme="http://mikiyonney.github.io/tags/android%20Emulator/"/>
    
      <category term="Android" scheme="http://mikiyonney.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Build a blog by Hexo && Node.js]]></title>
    <link href="http://mikiyonney.github.io/2014/01/07/Create-a-blog-by-Hexo/"/>
    <id>http://mikiyonney.github.io/2014/01/07/Create-a-blog-by-Hexo/</id>
    <published>2014-01-07T07:37:42.000Z</published>
    <updated>2014-03-16T07:38:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="用hexo+node-js搭建blog">用hexo+node.js搭建blog</h2>
<p>很久都没有学新东西了，三天前自己会的东西还是大学本科毕业后会的东西，在<a href="http://beforeload.github.io/" target="_blank">@beforeload</a>的指导下搭建了算是属于自己的blog,算是更新了一下自己的知识库了吧。跟什么样的人在一起就会成为什么样的人，跟优秀的人在一起无可厚非的收获匪浅~技术更新真的很快，感觉自己目前在技术这条路上渐行渐远的节奏可能决定了以后都无法回头了，先暂且不想这些吧！踏踏实实过好每天就对了~这篇blog纯当练手用，顺便总结下自己作为新手搭的这个blog的大致步骤（虽然<a href="http://zipperary.com/categories/hexo/" target="_blank">hexo系列教程</a>已经很多了）以及熟悉下<a href="http://wowubuntu.com/markdown/" target="_blank">markdown语法</a>。<br><a id="more"></a></p>
<p><strong>Step1: <a href="http://code.google.com/p/msysgit/" target="_blank">install git</a></strong></p>
<p><strong>Step2: <a href="http://nodejs.org/" target="_blank">install Node.js</a></strong></p>
<p><strong>Step3: <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a></strong></p>
<ul>
<li>Install:   $ npm install hexo -g </li>
<li>SetUp:     $ hexo init blog &amp;&amp; cd blog</li>
<li>Generate:  $ hexo generate     </li>
<li>Server:    $ hexo server</li>
</ul>
<p>这时你可以 visit <a href="http://localhost:4000" target="_blank">http://localhost:4000</a>.看看效果了。</p>
<p><strong>Step4: </strong></p>
<p>登录<a href="https://github.com/" target="_blank">github</a>,new repositories，建立一个新的repository，repository的名字账号名对应，账号名.github.io,如mikiyonney.github.io<br>生成SSH Keys，参考<a href="https://help.github.com/articles/generating-ssh-keys" target="_blank">SSH Generate</a></p>
<p><strong>Step5: 编辑E:\blog目录下_config.yml文件：</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="label">deploy:</span>
<span class="label">type:</span> github
<span class="label">repository:</span> git@github<span class="preprocessor">.com</span>:MiKiYonney/mikiyonney<span class="preprocessor">.github</span><span class="preprocessor">.io</span><span class="preprocessor">.git</span>
<span class="label">branch:</span> master
</pre></td></tr></table></figure>

<p>修改完本地文件后，用hexo generate 生成与保存（Hexo命令在E:\blog目录下执行）,然后hexo deploy部署，这样如果一路没出错的话，你就可以happy的直接访问mikiyonney.github.io看你的blog了。</p>
<p><strong>Step6: 学习MarkDown，写第一篇blog</strong></p>
<p>我大致是参考的学习文档如下：</p>
<p><a href="http://zipperary.com/2013/05/22/introduction-to-markdown/" target="_blank">MarkDown指南</a></p>
<p><a href="http://wowubuntu.com/markdown/" target="_blank">MarkDown官方文档</a></p>
<p>用MarkDown可视化编辑工具能事半功倍，如Windows下的<a href="http://markdownpad.com/" target="_blank">MarkDownPad</a>等等</p>
<p>然后 $ hexo new “New Post”，你就可以write whatever you want to write了。</p>
<p><strong>其他相关命令笔记</strong></p>
<ul>
<li><p>remove: $ rm -rf .deploy</p>
</li>
<li><p>$ hexo clean  —Cleans the cache file (db.json) and generated files (public).</p>
</li>
<li><p>Deploy</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>hexo <span class="keyword">generate</span> <span class="comment">--watch</span>
hexo deploy <span class="comment">--generate</span>
</pre></td></tr></table></figure>

<ul>
<li>hexo alias：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>hexo g == hexo generate
hexo d == hexo deploy
hexo s == hexo <span class="keyword">server</span>
hexo n == hexo <span class="keyword">new</span>
</pre></td></tr></table></figure>

<p><strong>其他参考</strong></p>
<ul>
<li><p><a href="http://yangjian.me/workspace/building-blog-with-hexo/" target="_blank">使用hexo搭建博客</a></p>
</li>
<li><p><a href="http://sys.la/2013/09/07/hexo/" target="_blank">hexo教程</a></p>
</li>
<li><p><a href="http://jiabin.tk/2013/06/21/using-hexo-as-blog-platform/" target="_blank">hexo blog</a></p>
</li>
</ul>
<hr>
]]></content>
    <summary type="html"><![CDATA[<h2 id="用hexo+node-js搭建blog">用hexo+node.js搭建blog</h2>
<p>很久都没有学新东西了，三天前自己会的东西还是大学本科毕业后会的东西，在<a href="http://beforeload.github.io/" target="_blank">@beforeload</a>的指导下搭建了算是属于自己的blog,算是更新了一下自己的知识库了吧。跟什么样的人在一起就会成为什么样的人，跟优秀的人在一起无可厚非的收获匪浅~技术更新真的很快，感觉自己目前在技术这条路上渐行渐远的节奏可能决定了以后都无法回头了，先暂且不想这些吧！踏踏实实过好每天就对了~这篇blog纯当练手用，顺便总结下自己作为新手搭的这个blog的大致步骤（虽然<a href="http://zipperary.com/categories/hexo/" target="_blank">hexo系列教程</a>已经很多了）以及熟悉下<a href="http://wowubuntu.com/markdown/" target="_blank">markdown语法</a>。<br>]]></summary>
    
      <category term="hexo" scheme="http://mikiyonney.github.io/tags/hexo/"/>
    
      <category term="node.js" scheme="http://mikiyonney.github.io/tags/node.js/"/>
    
      <category term="Hexo" scheme="http://mikiyonney.github.io/categories/Hexo/"/>
    
  </entry>
  
</feed>
